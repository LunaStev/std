import("std::mem");

fun len(s: str) -> i32 {
    let mut count: i32 = 0;
    while (s[count] != 0) {
        count = count + 1;
    }
    return count;
}

fun copy(dest: ptr<i8>, src: str, max_len: i32) -> i32 {
    let mut i: i32 = 0;
    while (i < max_len - 1 && src[i] != 0) {
        dest[i] = src[i];
        i = i + 1;
    }
    dest[i] = 0;
    return i;
}

fun concat(dest: ptr<i8>, src1: str, src2: str, max_len: i32) -> i32 {
    let len1: i32 = len(src1);
    let len2: i32 = len(src2);
    
    if (len1 + len2 >= max_len) {
        return -1; // not enough space
    }
    
    let mut i: i32 = 0;
    while (i < len1) {
        dest[i] = src1[i];
        i = i + 1;
    }
    
    let mut j: i32 = 0;
    while (j < len2) {
        dest[i + j] = src2[j];
        j = j + 1;
    }
    
    dest[i + j] = 0;
    return i + j;
}

fun compare(s1: str, s2: str) -> i32 {
    let mut i: i32 = 0;
    while (s1[i] != 0 && s2[i] != 0) {
        if (s1[i] < s2[i]) {
            return -1;
        }
        if (s1[i] > s2[i]) {
            return 1;
        }
        i = i + 1;
    }
    
    if (s1[i] == 0 && s2[i] == 0) {
        return 0;
    }
    if (s1[i] == 0) {
        return -1;
    }
    return 1;
}

fun find_char(s: str, c: i8) -> i32 {
    let mut i: i32 = 0;
    while (s[i] != 0) {
        if (s[i] == c) {
            return i;
        }
        i = i + 1;
    }
    return -1;
}

fun find_substring(haystack: str, needle: str) -> i32 {
    let haystack_len: i32 = len(haystack);
    let needle_len: i32 = len(needle);
    
    if (needle_len == 0) {
        return 0;
    }
    
    if (needle_len > haystack_len) {
        return -1;
    }
    
    let mut i: i32 = 0;
    while (i <= haystack_len - needle_len) {
        let mut j: i32 = 0;
        while (j < needle_len && haystack[i + j] == needle[j]) {
            j = j + 1;
        }
        if (j == needle_len) {
            return i;
        }
        i = i + 1;
    }
    
    return -1;
}

fun to_upper(s: ptr<i8>) {
    let mut i: i32 = 0;
    while (s[i] != 0) {
        if (s[i] >= 97 && s[i] <= 122) { // 'a' to 'z'
            s[i] = s[i] - 32;
        }
        i = i + 1;
    }
}

fun to_lower(s: ptr<i8>) {
    let mut i: i32 = 0;
    while (s[i] != 0) {
        if (s[i] >= 65 && s[i] <= 90) { // 'A' to 'Z'
            s[i] = s[i] + 32;
        }
        i = i + 1;
    }
}

fun parse_int(s: str) -> i32 {
    let mut result: i32 = 0;
    let mut i: i32 = 0;
    let mut negative: i32 = 0;
    
    if (s[0] == 45) { // '-'
        negative = 1;
        i = 1;
    }
    
    while (s[i] != 0) {
        if (s[i] >= 48 && s[i] <= 57) { // '0' to '9'
            result = result * 10 + (s[i] - 48);
        } else {
            break;
        }
        i = i + 1;
    }
    
    if (negative == 1) {
        result = -result;
    }
    
    return result;
}

fun int_to_string(value: i32, buffer: ptr<i8>, buffer_size: i32) -> i32 {
    if (buffer_size < 2) {
        return -1;
    }
    
    let mut negative: i32 = 0;
    let mut num: i32 = value;
    
    if (num < 0) {
        negative = 1;
        num = -num;
    }
    
    let mut digits: i32 = 0;
    let mut temp: i32 = num;
    
    if (temp == 0) {
        digits = 1;
    } else {
        while (temp > 0) {
            digits = digits + 1;
            temp = temp / 10;
        }
    }
    
    let total_len: i32 = digits + negative;
    if (total_len >= buffer_size) {
        return -1;
    }
    
    buffer[total_len] = 0;
    
    let mut i: i32 = total_len - 1;
    while (i >= negative) {
        buffer[i] = (num % 10) + 48; // '0'
        num = num / 10;
        i = i - 1;
    }
    
    if (negative == 1) {
        buffer[0] = 45; // '-'
    }
    
    return total_len;
}