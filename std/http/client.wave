import("std::http");
import("std::network::socket");
import("std::core::string");
import("std::mem");

const HTTP_CLIENT_SIZE: i32 = 24; // i32(4) + i32(4) + ptr<i8>(8) + i16(2) + padding(6) = 24 bytes

struct HttpClient {
    socket_fd: i32,
    connected: i32,
    host: ptr<i8>,
    port: i16,
}

fun create_http_client() -> ptr<HttpClient> {
    let client: ptr<HttpClient> = alloc(HTTP_CLIENT_SIZE) as ptr<HttpClient>;
    if (client == 0 as ptr<HttpClient>) {
        return 0 as ptr<HttpClient>;
    }
    
    client.socket_fd = -1;
    client.connected = 0;
    client.host = 0 as ptr<i8>;
    client.port = 80;
    
    return client;
}

fun http_client_connect(client: ptr<HttpClient>, host: str, port: i16) -> i32 {
    if (client.connected == 1) {
        close_socket(client.socket_fd);
        client.connected = 0;
    }
    
    // Create socket
    client.socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (client.socket_fd < 0) {
        return -1;
    }
    
    // Store host and port
    if (client.host != 0 as ptr<i8>) {
        free(client.host);
    }
    let host_len: i32 = len(host);
    client.host = alloc(host_len + 1);
    if (client.host == 0 as ptr<i8>) {
        close_socket(client.socket_fd);
        return -1;
    }
    copy(client.host, host, host_len + 1);
    client.port = port;
    
    // Create address
    let addr: ptr<sockaddr_in> = create_sockaddr_in(host, port);
    if (addr == 0 as ptr<sockaddr_in>) {
        close_socket(client.socket_fd);
        return -1;
    }
    
    // Connect
    let result: i32 = connect(client.socket_fd, addr as ptr<u8>, SOCKADDR_IN_SIZE);
    free(addr);
    
    if (result < 0) {
        close_socket(client.socket_fd);
        return -1;
    }
    
    client.connected = 1;
    return 0;
}

fun http_client_get(client: ptr<HttpClient>, path: str) -> ptr<HttpResponse> {
    if (client.connected == 0) {
        return 0 as ptr<HttpResponse>;
    }
    
    // Build GET request
    let request_size: i32 = 14 + len(path) + 11 + len(client.host) + 26; // "GET " + path + " HTTP/1.1\r\nHost: " + host + "\r\nConnection: close\r\n\r\n"
    let request: ptr<i8> = alloc(request_size);
    if (request == 0 as ptr<i8>) {
        return 0 as ptr<HttpResponse>;
    }
    
    let mut pos: i32 = 0;
    pos = pos + copy(request + pos, "GET ", request_size - pos);
    pos = pos + copy(request + pos, path, request_size - pos);
    pos = pos + copy(request + pos, " HTTP/1.1\r\nHost: ", request_size - pos);
    pos = pos + copy(request + pos, client.host, request_size - pos);
    pos = pos + copy(request + pos, "\r\nConnection: close\r\n\r\n", request_size - pos);
    
    // Send request
    let bytes_sent: i32 = send(client.socket_fd, request as ptr<u8>, pos, 0);
    free(request);
    
    if (bytes_sent < 0) {
        return 0 as ptr<HttpResponse>;
    }
    
    // Receive response
    let response_buffer: ptr<i8> = alloc(8192);
    if (response_buffer == 0 as ptr<i8>) {
        return 0 as ptr<HttpResponse>;
    }
    
    let total_received: i32 = 0;
    let mut bytes_received: i32;
    
    while (total_received < 8191) {
        bytes_received = recv(client.socket_fd, (response_buffer + total_received) as ptr<u8>, 8191 - total_received, 0);
        if (bytes_received <= 0) {
            break;
        }
        total_received = total_received + bytes_received;
    }
    
    response_buffer[total_received] = 0;
    
    // Parse response
    let response: ptr<HttpResponse> = alloc(HTTP_RESPONSE_SIZE) as ptr<HttpResponse>;
    if (response == 0 as ptr<HttpResponse>) {
        free(response_buffer);
        return 0 as ptr<HttpResponse>;
    }
    
    // Simple response parsing (just for basic functionality)
    let result: i32 = parse_http_response(response_buffer, response);
    free(response_buffer);
    
    if (result < 0) {
        free(response);
        return 0 as ptr<HttpResponse>;
    }
    
    return response;
}

fun http_client_post(client: ptr<HttpClient>, path: str, body: str, content_type: str) -> ptr<HttpResponse> {
    if (client.connected == 0) {
        return 0 as ptr<HttpResponse>;
    }
    
    let body_len: i32;
    if (body != 0 as str) {
        body_len = len(body);
    } else {
        body_len = 0;
    }
    
    // Build POST request
    let content_len_str: [i8; 16];
    int_to_string(body_len, content_len_str, 16);
    
    let request_size: i32 = 15 + len(path) + 11 + len(client.host) + 16 + len(content_type) + 18 + len(content_len_str) + 26 + body_len;
    let request: ptr<i8> = alloc(request_size);
    if (request == 0 as ptr<i8>) {
        return 0 as ptr<HttpResponse>;
    }
    
    let mut pos: i32 = 0;
    pos = pos + copy(request + pos, "POST ", request_size - pos);
    pos = pos + copy(request + pos, path, request_size - pos);
    pos = pos + copy(request + pos, " HTTP/1.1\r\nHost: ", request_size - pos);
    pos = pos + copy(request + pos, client.host, request_size - pos);
    pos = pos + copy(request + pos, "\r\nContent-Type: ", request_size - pos);
    pos = pos + copy(request + pos, content_type, request_size - pos);
    pos = pos + copy(request + pos, "\r\nContent-Length: ", request_size - pos);
    pos = pos + copy(request + pos, content_len_str, request_size - pos);
    pos = pos + copy(request + pos, "\r\nConnection: close\r\n\r\n", request_size - pos);
    
    if (body != 0 as str && body_len > 0) {
        pos = pos + copy(request + pos, body, request_size - pos);
    }
    
    // Send request
    let bytes_sent: i32 = send(client.socket_fd, request as ptr<u8>, pos, 0);
    free(request);
    
    if (bytes_sent < 0) {
        return 0 as ptr<HttpResponse>;
    }
    
    // Receive response (same as GET)
    let response_buffer: ptr<i8> = alloc(8192);
    if (response_buffer == 0 as ptr<i8>) {
        return 0 as ptr<HttpResponse>;
    }
    
    let total_received: i32 = 0;
    let mut bytes_received: i32;
    
    while (total_received < 8191) {
        bytes_received = recv(client.socket_fd, (response_buffer + total_received) as ptr<u8>, 8191 - total_received, 0);
        if (bytes_received <= 0) {
            break;
        }
        total_received = total_received + bytes_received;
    }
    
    response_buffer[total_received] = 0;
    
    // Parse response
    let response: ptr<HttpResponse> = alloc(HTTP_RESPONSE_SIZE) as ptr<HttpResponse>;
    if (response == 0 as ptr<HttpResponse>) {
        free(response_buffer);
        return 0 as ptr<HttpResponse>;
    }
    
    let result: i32 = parse_http_response(response_buffer, response);
    free(response_buffer);
    
    if (result < 0) {
        free(response);
        return 0 as ptr<HttpResponse>;
    }
    
    return response;
}

fun http_client_disconnect(client: ptr<HttpClient>) {
    if (client.connected == 1) {
        close_socket(client.socket_fd);
        client.connected = 0;
        client.socket_fd = -1;
    }
}

fun free_http_client(client: ptr<HttpClient>) {
    if (client.connected == 1) {
        close_socket(client.socket_fd);
    }
    if (client.host != 0 as ptr<i8>) {
        free(client.host);
    }
    free(client);
}

// Simple response parser (minimal implementation)
fun parse_http_response(data: str, resp: ptr<HttpResponse>) -> i32 {
    let mut pos: i32 = 0;
    
    // Initialize response
    resp.version = 0 as ptr<i8>;
    resp.status_code = 0;
    resp.status_text = 0 as ptr<i8>;
    resp.header_count = 0;
    resp.body = 0 as ptr<i8>;
    resp.body_length = 0;
    
    // Find first space (after version)
    while (data[pos] != 0 && data[pos] != 32) {
        pos = pos + 1;
    }
    if (data[pos] == 0) {
        return -1;
    }
    
    // Copy version
    resp.version = alloc(pos + 1);
    if (resp.version == 0 as ptr<i8>) {
        return -1;
    }
    copy(resp.version, data, pos + 1);
    
    pos = pos + 1; // skip space
    
    // Parse status code
    let status_start: i32 = pos;
    while (data[pos] != 0 && data[pos] != 32) {
        pos = pos + 1;
    }
    if (data[pos] == 0) {
        return -1;
    }
    
    let status_str: ptr<i8> = alloc(pos - status_start + 1);
    if (status_str == 0 as ptr<i8>) {
        return -1;
    }
    copy(status_str, data + status_start, pos - status_start + 1);
    resp.status_code = parse_int(status_str);
    free(status_str);
    
    pos = pos + 1; // skip space
    
    // Parse status text
    let status_text_start: i32 = pos;
    while (data[pos] != 0 && data[pos] != 13 && data[pos] != 10) {
        pos = pos + 1;
    }
    
    resp.status_text = alloc(pos - status_text_start + 1);
    if (resp.status_text == 0 as ptr<i8>) {
        return -1;
    }
    copy(resp.status_text, data + status_text_start, pos - status_text_start + 1);
    
    // Skip to headers (simple implementation - skip line endings)
    while (data[pos] == 13 || data[pos] == 10) {
        pos = pos + 1;
    }
    
    // Skip headers (for simplicity, just find double newline)
    while (data[pos] != 0) {
        if ((data[pos] == 13 && data[pos + 1] == 10 && data[pos + 2] == 13 && data[pos + 3] == 10) ||
            (data[pos] == 10 && data[pos + 1] == 10)) {
            pos = pos + (data[pos] == 13 ? 4 : 2);
            break;
        }
        pos = pos + 1;
    }
    
    // Parse body
    if (data[pos] != 0) {
        let body_len: i32 = len(data + pos);
        if (body_len > 0) {
            resp.body = alloc(body_len + 1);
            if (resp.body != 0 as ptr<i8>) {
                copy(resp.body, data + pos, body_len + 1);
                resp.body_length = body_len;
            }
        }
    }
    
    return 0;
}